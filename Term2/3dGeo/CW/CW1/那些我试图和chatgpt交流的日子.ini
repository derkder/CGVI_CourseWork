我在做icp对齐两个mesh的问题，写出来下面的代码：
mesh_src = os.path.join(RES_PATH, 'bun000_v2.ply')
assert os.path.exists(mesh_src), 'cannot found:' + mesh_src
mesh1 = o3d.io.read_triangle_mesh(mesh_src)
mesh_dst = os.path.join(RES_PATH, 'bun045_v2.ply')
assert os.path.exists(mesh_dst), 'cannot found:' + mesh_dst
mesh2 = o3d.io.read_triangle_mesh(mesh_dst)

points_A = np.asarray(mesh1.vertices)
points_B = np.asarray(mesh2.vertices)

def best_fit_transform(A, B, weights=None):
    assert len(A) == len(B)

    if weights is None:
        weights = np.ones(len(A))

    centroid_A = np.average(A, axis=0, weights=weights)
    centroid_B = np.average(B, axis=0, weights=weights)

    AA = A - centroid_A
    BB = B - centroid_B

    # 直接应用权重，避免创建大的对角矩阵
    AA_weighted = AA * weights[:, np.newaxis]
    H = AA_weighted.T @ BB

    U, S, Vt = np.linalg.svd(H)
    R = Vt.T @ U.T
    if np.linalg.det(R) < 0:
        Vt[2, :] *= -1
        R = Vt.T @ U.T
    t = centroid_B.T - R @ centroid_A.T
    t = t.reshape(-1, 1)
    return R, t

def icp(src_cp, dst_cp, max_iterations=100, tolerance=1e-4, close_proximity_threshold=1e-4):
    start_time = time.time()
    src = np.copy(src_cp)
    dst = np.copy(dst_cp)
    prev_error = np.inf
    tree = KDTree(dst)

    for i in range(max_iterations):
        distances, indices = tree.query(src, k = 1)
        weights = 1.0 / (distances + 1e-6)
        T = best_fit_transform(src, dst[indices], weights=weights)
        src = (T[0] @ src.T + T[1]).T
        mean_error = np.mean(distances)
        sum_srror = np.sum(distances)
        if np.abs(prev_error - mean_error) < tolerance  or sum_srror < close_proximity_threshold:
            break
        prev_error = mean_error

    T = best_fit_transform(src_cp, src, weights=weights)
    total_time = time.time() - start_time
    return T[0], T[1], i, total_time 


R, t, iterations, time_total = icp(points_B, points_A)
mesh2.transform(np.vstack((np.hstack((R, t)), [0, 0, 0, 1])))
visualize_iteration(points_A, points_B)

# 可视化对齐后的网格
o3d.visualization.draw_geometries([mesh1, mesh2])
aligned_mesh_path = os.path.join(RES_PATH, 'bun045_v2_aligned.ply')
combined_mesh = mesh1 + mesh2  # 合并网格
o3d.io.write_triangle_mesh(aligned_mesh_path, combined_mesh)  # 保存合并后的网格
现在要求你在我的代码基础上，进行修改，完成图片中的题，并返回给我修改完的代码，请注意不要用错我这里的函数，不要看错题，否则100000个无辜的老奶奶会死亡